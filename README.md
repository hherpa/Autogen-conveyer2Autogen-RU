# Требуемые нововведения в autogen
## Autogen-conveyer и его отделы:
1. Что это и зачем это нужно? (* Autogen-conveyer - это новый подход к....)
2. из чего состоит конвейер (отделы, подотделы)
3. основная проблема: парсинг результата отдела (+ наша идея с агентов что будет помечать результат чата тегом @final)
4. pipeline
## Новый класс агентов! ClI_Agent
CLI_Agent - это класс агентов для постоянного анализа группового чата autogen и выполнения определенных функций при срабатывании условий. Эти фукнции деляться на два типа: `&command_name` и `!edit_memory`.
В памяти агента класса CLI_Agent может содержаться информация, которая должна считаться истинной для чата, в котором он участвует. Агент данного класса может использовать команду в формате ```!edit_memory <старое значение><новое значение> @Agent_name```, чтобы обратиться к обработчику команд и изменить в памяти определённого агента информацию, которая расходиться с той что находиться в его памяти. Таким образом, агент CLI_Agent может поддерживать точность и актуальность информации в групповом чате.

![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/02d4e87b-cd06-475e-a3b4-46668c328320)

Если команда `!edit_memory` является заготовленной, то `&command_name` - это пользовательские команды. Например в конвейере Conveyer2Autogen есть отдел создания списка ролей. Мы тестировали этот отдел и нам всегда приходилось корректировать его работу писав на фидбэках: "выведи список полностью", "эта роль является лишней", "в списке слишком мало ролей - добавь ещё". Эту проблему решил Regulatory agent класса CLI_Agent использовавший пользовательские команды:
* `&cleared_out` - обозначает, что список написан неправильно и не касается задачи пользователя
* `&add_more` - обозначает, что список слишком короткий и его нужно увеличить
* `&only_list` - обозначает, что агент вывел что-то ещё кроме списка, что следовало исправить
Пользователь точно также может описать агенту класса CLI_Agent свои условия срабатывания и точно также получать верные результаты!

## Два варианта реализаци класса CLI_Agent
При использовании autogen ты понимаешь, что правильным подходом является "один аген - одна функция" (про такой фукнкциональный подход еще будет говориться далее), а поэтому есть два варианта реализации класса CLI_Agent.
1. **Обработчик находиться изначально в AssistantAgent:**

![9](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/af71986e-b2ce-4c0f-a3af-0566d2030ffe)

2. **Обработчик является отдельным классом агентов:**

![11](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/644bc01b-d94e-400f-8645-d9876cff31e3)

# универсальный агент "Мотиватор"
Исходя из нашего опыта использования autogen агенты бывают двух типов:

![AgentTypesRu](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/c1a509a0-1b17-42c9-87bd-ce2a809ab122)

Всё чаще и чаще стали появляться исследовании о влиянии определенных манипуляций/мотиваций в промтах на качество ответа LLM. Мы решили собрать все промты из этих исследований (начиная с "От этого зависит моя карьера..." до "Сейчас май...") и создать агента, что будет подстраиваться под каждую роль в чате и перед тем как она что-то напишет улучшать её результат с помощью подобного "Франкенштейна". Мы назвали этого агента "Мотиватор" и используем его по сей день в autogen. Но этот агент точно требует доработки так как мы все понимаем, что даже одного слово в промте может испортить результат, а поэтому нужно досканально проанализировать комбинации промтов которые мы брали из иследований, а также их полезность, так как например шаблон "...я заплачу тебе 200$ за то что ты сделаешь это правильно" пришлось убрать так как он лишь ухудшает результат и автор этого шаблона ошибся в своей работе о чем писал в соц.сетях.
# Conveyer2Autogen
![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/6b8acf93-9bf4-42d0-97ed-051dd25d541a)

Conveyer2Autogen - позволяет пользователю получить целый групповой чат autogen с правильно прописанными и протестированными промтами, интегрированными утилитами в агентов, а также function call. Также Conveyer2Autogen из-за своей простоты подхода "prompt --> answer и ничего лишнего" имеет свой TUI. Мы считаем это очень важной деталью так как это позволит большему количеству людей познакомиться с autogen и начать им пользоваться без написания кода 

## разбор пайплана Conveyer2Autogen
```
Глобальный план работы Conveyer2Autogen:
1. Создание списка ролей/агентов по промту пользователя
2. Выбор класса для каждого агента в списке
3. Написание промта для каждого агента в списке
4. Анализ того нужен ли кому нибудь в списке агентов интегрируемый инструмент
  4.1. Интеграция инструмента для определенного агента
5. Анализ того нужен ли кому нибудь в списке агентов function call
  5.1 Поиск кода function call в rag и его интеграция в агента
  5.2 Если код function call не найден - генерация кода function call и его интеграция в агента
6. Сборка
```
### 1. Создание списка ролей/агентов
![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/0b533c40-1b21-4ca5-9981-5493ba17add4)

Здесь всё интуитивно понятно на входе промт пользователя, а уже на выходе список ролей. Здесь как раз таки видно как примерно будут встраиваться Regulatory Agent (класса CLI_Agent) и Motivator в групповые чаты autogen.

* **Пример реализации в TUI:**
  
![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/6d83f249-7e80-4597-8788-a2cee91573d7) ![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/9590f64e-1054-42cb-964b-ad41683be8b1)

### 2. Выбор класса для каждого агента в списке
![image](https://github.com/hherpa/Conveyer2Autogen-RU/assets/146547175/8f0ebafa-3501-4f3e-a9b3-cee6082dcbc6)

1. разбор Pipeline по частям
2. Этот pipeline не точен так как должен быть больше как минимум в два раза....правило дифференцирования: один агент одна функция
3. Ссылочная модель за место орекстратора
# Conveyer2Conveyer
1. описание
# Autogen-Ship
1. Описание
2. Три варианта создания отдела:
  2.1 Conveyer2Autogen
  2.2 Conveyer2Conveyer
  2.3 Вручную
